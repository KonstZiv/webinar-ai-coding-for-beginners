# Послідовність промптів для створення проєкту

Ця таблиця описує кроки для створення консольної гри Tic-Tac-Toe з AI-кодуванням.

## Task 1: Базова гра з Rich UI

| # | Промпт | Результат | Таска на борді |
|---|--------|-----------|----------------|
| 1 | **Ініціалізуй Python-проєкт для консольної гри Tic-Tac-Toe. Використовуй `uv` для залежностей, додай `tic-tac-toe-3x3` та `rich`. Створи базову структуру `src/my_tic_tac_toe/`.** | `pyproject.toml`, `src/my_tic_tac_toe/__init__.py`, `.venv`, встановлені залежності | **Назва:** Ініціалізація проєкту<br><br>**Що зробити:** Створити структуру Python-проєкту з налаштованим середовищем<br><br>**Як:** Використати `uv init`, додати залежності `tic-tac-toe-3x3` та `rich`, створити директорію `src/my_tic_tac_toe/` з `__init__.py`<br><br>**Очікуваний результат:** Проєкт запускається без помилок, залежності встановлені, структура відповідає стандарту src-layout |
| 2 | **Створи `RichRenderer` що наслідує `tic_tac_toe_3x3.game.renderers.Renderer`. Клітинки 17×7 символів, X (червоний) та O (синій) малюються блоками █, сітка з подвійних ліній (╔╗╚╝), колонки A/B/C, ряди 1/2/3, статус гри знизу, виграшні клітинки підсвічуються reverse style. Додай `__main__.py` для запуску.** | `renderer.py` з повною реалізацією, `__main__.py`, працююча гра `uv run python -m my_tic_tac_toe` | **Назва:** Rich Renderer — красиве відображення дошки<br><br>**Що зробити:** Реалізувати кастомний рендерер для гри з кольоровим ASCII art<br><br>**Як:** Створити клас `RichRenderer` (наслідує `Renderer`), клітинки 17×7 символів, X=червоний/O=синій блоками █, сітка подвійними лініями, підсвітка виграшу reverse style<br><br>**Очікуваний результат:** Гра запускається командою `uv run python -m my_tic_tac_toe`, відображає красиву кольорову дошку |
| 3 | **Напиши pytest тести для RichRenderer: наслідування, розміри ASCII art, статуси гри, рендеринг клітинок, всі 8 виграшних комбінацій. Додай GitHub Actions CI з ruff lint та pytest.** | `tests/test_renderer.py` (40+ тестів), `.github/workflows/ci.yml` | **Назва:** Тести та CI/CD pipeline<br><br>**Що зробити:** Покрити код тестами та налаштувати автоматичну перевірку<br><br>**Як:** Написати pytest тести для RichRenderer (наслідування, ASCII art, статуси, 8 виграшних комбінацій), створити GitHub Actions workflow з ruff check та pytest<br><br>**Очікуваний результат:** 40+ тестів проходять, CI запускається на push/PR до main, код проходить лінтинг |
| 4 | **Додай CLI опції `--ai` (minimax/random) та `--ai-first` для гри з комп'ютером. Онови README.md з інструкціями запуску.** | Оновлений `__main__.py` з argparse, README.md з документацією | **Назва:** Режим гри з AI<br><br>**Що зробити:** Додати можливість грати проти комп'ютера<br><br>**Як:** Використати `argparse` для CLI опцій `--ai` (minimax/random) та `--ai-first`, інтегрувати `MinimaxComputerPlayer` та `RandomComputerPlayer` з бібліотеки, оновити README<br><br>**Очікуваний результат:** Гра підтримує режими human vs human, human vs AI (minimax/random), AI ходить першим за опцією `--ai-first` |

## Task 2: Cascade Effect та покращення UI

| # | Промпт | Результат | Таска на борді |
|---|--------|-----------|----------------|
| 5 | **Зроби щоб екран оновлювався на місці без скролінгу. Використай ANSI escape codes (cursor home `\033[H`, clear screen `\033[2J`). Створи `RichPlayer` клас що наслідує `Player` і використовує `renderer` для вводу з перемальовуванням екрану при помилках.** | `renderer.py` з ANSI cursor positioning, `player.py` з `RichPlayer`, оновлений `__main__.py` | **Назва:** In-place оновлення екрану та RichPlayer<br><br>**Що зробити:** Прибрати скролінг при оновленні дошки, створити кастомний Player<br><br>**Як:** Замінити `console.clear()` на ANSI escape codes (`\033[H` для cursor home), створити `RichPlayer` що використовує renderer для відображення помилок вводу<br><br>**Очікуваний результат:** Дошка оновлюється на місці, помилки вводу показуються без скролінгу |
| 6 | **Реалізуй Cascade Effect для кінця гри: після перемоги/нічиї символи "осипаються" вниз. Створи пакет `cascade/` з модулями `keyboard.py` (non-blocking input через termios/select), `particle.py` (Particle dataclass), `animation.py` (CascadeAnimation). При перемозі виграшні клітинки залишаються на місці (frozen), інші падають. При нічиї — всі падають. Символи накопичуються внизу екрану. Space перериває анімацію.** | `cascade/keyboard.py`, `cascade/particle.py`, `cascade/animation.py`, `cascade/__init__.py`, інтеграція в `renderer.py` | **Назва:** Cascade Effect — анімація падаючих символів<br><br>**Що зробити:** Реалізувати ефект "осипання" символів після закінчення гри<br><br>**Як:** Створити `cascade/` пакет: `NonBlockingInput` (termios/select), `Particle` dataclass, `CascadeAnimation` клас. Frozen частинки для виграшних клітинок. ANSI cursor positioning для анімації. Space для переривання.<br><br>**Очікуваний результат:** Після гри символи плавно падають вниз і накопичуються, виграшна комбінація залишається на місці |
| 7 | **Покращ Cascade Effect: 1) Зменши швидкість падіння в 3-4 рази. 2) Додай spin — кожен символ "крутиться" вліво або вправо. При зіткненні з перешкодою символ зміщується в бік свого spin якщо там є місце, інакше зупиняється. 3) Виграшна комбінація пульсує: плавно світлішає до максимуму і гасне до темно-сірого в циклі (використай синусоїду для плавності).** | Оновлені `particle.py` (поле `spin`), `animation.py` (логіка slide, пульсація з `math.sin`, кольори `PULSE_COLORS_RED/BLUE`) | **Назва:** Cascade Effect — фізика та пульсація<br><br>**Що зробити:** Додати реалістичну фізику падіння та візуальний ефект пульсації<br><br>**Як:** Додати `spin` поле до Particle (-1/+1). В update() перевіряти бокове зміщення при зіткненні. Для пульсації: лічильник кадрів + `math.sin()` для фази, масиви кольорів від grey30 до bright_red/blue.<br><br>**Очікуваний результат:** Символи "котяться" вбік при падінні, виграшна комбінація плавно пульсує від темного до яскравого |
